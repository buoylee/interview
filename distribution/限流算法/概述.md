[toc]

## 概述

### 固定窗口

当前时间对比的是上次记录的**窗口开始**的timestamp,
且粒度较大, 可以导致,在**本次窗口的结尾**和**下次窗口的开头**的时间段内超过设定的qps.

### 滑动窗口

array: array<requestObj<timestamp(超出窗口则update), count(超出窗口则归零)>> 最后统计所有子窗口内的request总数,
整体思路是, 

### 滑动日志

思路与滑动窗口大致相同,
linklist: 改为记录request的timestamp, 清除窗口外的request, 每次都用**当前timestamp作为窗口结尾**统计在**窗口内的request总数**来判断是否达到阈值.

### 漏桶算法

每次request, 都与上次request timestamp比较时间差, 并计算可以漏水量(这次柯通过的request数),
先减去可以漏的水, 
查看当前的桶是否满, 不满, 水量+1(当前request); 满, 触发限流策略.

### 令牌桶算法





## 对比

[常用 4 种限流算法介绍及比较](https://cloud.tencent.com/developer/article/2042810)

[掌握四种常用限流算法，面试包过](https://www.51cto.com/article/773434.html)

[限流算法选择](https://help.aliyun.com/document_detail/149952.html)

[限流算法如何选择？时间敏感，QPS，集群](https://blog.csdn.net/fly910905/article/details/123120451)

## 参考

[5种限流算法，7种限流方式，挡住突发流量？ ](https://www.cnblogs.com/niumoo/p/16007224.html)

[使用漏桶算法实现一秒钟50个限流](https://www.51cto.com/article/772532.html)

[常见限流算法介绍（漏桶算法、令牌桶算法）及实现--待整理 ](https://www.cnblogs.com/duanxz/p/4123068.html) **现实场景实现**