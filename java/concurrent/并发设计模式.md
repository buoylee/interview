## 终止线程的设计模式

**如何在一个线程T1 中如何正确安全的终止线程T2？**



### Thread#stop()

**不建议使用stop(), 会不正常的释放锁, 没有正常的退出, 结果不可预知,** 



### Two-phase Termination(两阶段终止)模式--优雅的终止线程

第一个阶段主要是线程T1**向线程 T2发送终止指令**，第二阶段则是**线程T2响应终止指令**.
Java 线程**进入终止状态的前提是进入RUNNABLE状态**, 利用java的 interrupt()方法(会抛出异常), 将线程从休眠到runnable状态, 并设置标志位, 在检查标志位的代码时, 合理退出线程.
**注意:** 有些程序**使用了清除标志位的interupt(). 需要重新设置标志位**, 或者**使用变量来表示终止与否**.

<img src="Screenshot 2024-11-19 at 04.04.45.png" alt="Screenshot 2024-11-19 at 04.04.45" style="zoom:50%;" />



## 避免共享的设计模式

<img src="Screenshot 2024-11-19 at 04.06.07.png" alt="Screenshot 2024-11-19 at 04.06.07" style="zoom: 33%;" />

### Immutability模式

解决并发问题最简单的办法就是**让共享变量只有读操作**，而没有写操作。
所谓不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化。

#### 实现

设置成 final, 例如 String 和 Long、Integer、Double 等基础类型的包装类. 类和属性都是 final 的，所有方法均是只读的。

#### 使用 Immutability 模式的注意事项

在使用Immutability 模式的时候一定要确认保持不变性的边界在哪里，是否要求属性对象也具备不可变性。
可变对象虽然是线程安全的，但是并不意味着引用这些不可变对象的对象就是线程安全的。



## Copy-on-Write模式

不可变对象的写操作往往都是使用 Copy-on-Write 方法解决的.

Copy-on-Write **缺点就是消耗内存**, **读多写少的场景**, **可以尝试使用** Copy-on-Write。

### 应用场景

在Java中, 有 CopyOnWriteArrayList 和 CopyOnWriteArraySet.
通过 Copy-on-Write 这两个容器实现的**读操作是无锁的**，所以将**读操作的性能发挥到了极致**。**写有加锁.**

Copy-on-Write 在操作系统领域也有广泛的应用。
Linux 中fork()子进程的时候，并不复制整个进程的地址空间,而是让父子进程享同一个地址空间;**只用在**父进程或者子进程需要写入的时侯才会复制地址空间,从而使**父子进程拥有各自的地址空间**。

Copy-on-Write 最大的应用领域还是在函数式编程领域。函数式编程的基础是不可变性（Immutability）, 

像一些**RPC框架**还有**服务注册中心**，也会利用Copy-on-Wite设计思想**维护服务路由表**。路由表是典型的**读多写少**，而且
路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有5秒钟延迟，很多时候也都是
能接受的。



## Thread-Specific Storage 模式(多线程版本的if)--没有共享就没有伤害

是一种即使**只有一个入口**，也会**在内部为每个线程分配特有的存储空间**的模式。
在 Java 标准类库中，**ThreadLocal** 类实现了该模式。

如果需要在**并发场景中**使用一个**线程不安全的**工具类，最简单的方案就是避免共享。**避免共享有两种方案**，
一种方案是将这个工具类**作为局部变量**使用，
另外一种方案就是**Thread-Specific Storage(线程本地存储模式)**。

### 应用场景

SimpleDateFormat不是线程安全的, 用 ThreadLocal 来存.
**注意: **在线程池中使用ThreadLocal 需要**避免内存泄漏和线程安全的问题**.

## 多线程版本的if模式

Guarded Suspension 模式是通过**让线程等待来保护实例的安全性，即守护-挂起模式**。
一个线程**需要等待另外的线程完成后继续下一步操作**。这种模式可以帮助我们解决上述的等待问题。

Guarded Suspension 模式**允许多个线程对实例资源进行访问**，但是实例资源需要**对资源的分配做出管理**。

### 使用场景

<img src="Screenshot 2024-11-19 at 04.58.17.png" alt="Screenshot 2024-11-19 at 04.58.17" style="zoom: 33%;" />



## Balking模式--不需要就算了

Balking是“退缩不前”的意思。如果不适合或者没必要执行这个操作，就停止处理，直接返回。
**当流程的执行顺序依赖于某个共享变量的场景，可以归纳为多线程if模式**。
Balking 模式常用于**一个线程发现另一个线程已经做了某一件相同的事，那么本线程就无需再做了**，直接结束返回。



### 应用场景

双确认单例模式



## 多线程分工模式

### Thread-Per-Message 模式

Thread-Per-Message 模式就是**为每个任务分配一个独立的线程**.

#### 应用场景

最经典的应用场景是**网络编程里服务端的实现**，服务端**为每个客户端请求创建一个独立的线程**，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。

在其他编程语言里，例如 Go 语言，基于轻量级线程实现 Thread-Per-Message 模式就完全没有问题。

要想**有效避免线程的频繁创建、销毁以及 OOM 问题**，就不得不提Java 领域使用最多的 **Worker Thread 模式**。

### Worker Thread 模式实现

线程池实现



## 生产者- 消费者模式——用流水线的思想提高效率

生产者- 消费者模式的核心是一个任务队列

### 生产者/消费者模式的优点

支持异步处理, 

场景: MQ, **注册写数据库**, 再发注册短信.

### 解耦
场景: 用户**下单后**，订单系统需要通知库存系统**扣减库存**。

### 过饱问题解决方案(消息堆积)

<img src="Screenshot 2024-11-19 at 05.31.58.png" alt="Screenshot 2024-11-19 at 05.31.58" style="zoom: 25%;" />

**我们只要在业务可以容忍的最长响应时间内，把堆积的任务处理完，那就不算过饱。**

场景1: 如果**超过可容忍最长响应时间**, **消费者加机器**

场景2: 没超过可容忍最长响应时间, 只是生产者速度太快, 队列塞满; 队列加大.

场景3: 如果以上都不行, 生产者限流