## 临界区(Critical Section)

多个线程对共享资源**同时出现读和写操作时发生指令交错，就会出现问题**,
一段代码块中, 如果**对共享资源的多线程读写操作，这段代码块称为临界区**，其**共享资源为临界资源**.

## 竞态条件(Race Condition)

**多个线程在临界区内执行**，由于代码的执行序列不同而**导致结果无法预测**，称之为发生了**竞态条件**.

### 解决方案

阻塞式的解决方案：synchronized, Lock
非阻塞式的解决方案：原子变量(cas/自旋)

## synchronized底层原理

是JVM内置锁，基于**Monitor**机制实现，依赖底层操作系统的**互斥原语Mutex（互斥量）**，它是一个重量级锁，性能较低。当然，JVM内置锁在1.5之后版本做了重大的优化.

Java虚拟机通过一个**同步结构支持方法和方法中的指令序列的同步**：monitor。
**同步方法**是通过**方法中的access_flags**中设置**ACC_SYNCHRONIZED**标志来实现；
**同步代码块**是通过**monitorenter和monitorexit**来实现。两个指令的执行是JVM通过调用**操作系统的互斥原语mutex来实现**，被阻塞的线程会被挂起、等待重新调度，会导致**“用户态和内核态”两个态之间来回切换**，**性能有较大影响**。

<img src="Screenshot 2024-11-14 at 03.18.46.png" alt="Screenshot 2024-11-14 at 03.18.46" style="zoom:50%;" />

## Monitor(管程/监视器)

管程是指**管埋共享变量以及对共享变量操作的过程**，让它们支持并发。

synchronized关键字和wait()、notify()、notifyAII() 这三个方法是Java中**实现管程技术的组成部分**。

使用了以下**MESA模型**, 包括: 
入口队列, 
条件变量等待队列, 条件变量相当于condition
各种方法: wait, notify...

<img src="Screenshot 2024-11-14 at 15.16.12.png" alt="Screenshot 2024-11-14 at 15.16.12" style="zoom:50%;" />

因为可能调用**notifyAll, 唤醒了条件不符的, 不应该唤醒的线程**, 所以, 有一个编程范式,
```
while(condition){ //不满足, 才会被唤醒
	wait()
}
```

还需要**给wait一个超时时间, 避免永久阻塞**.

## java的**Monitor基于对象实现**

依赖于ObjectMonitor 实现，这是 JVM 内部基于C++实现的一套机制。
可以理解为一个obj 对应一个 Monitor

有以下数据结构, 包含了锁所需要的字段.

<img src="Screenshot 2024-11-14 at 15.32.31.png" alt="Screenshot 2024-11-14 at 15.32.31" style="zoom:50%;" />

<img src="Screenshot 2024-11-14 at 15.40.38.png" alt="Screenshot 2024-11-14 at 15.40.38" style="zoom:50%;" />

抢到锁的线程wait(),会放入EntryList, sleep()放入_cxq(FILO), EntryList可能会优先唤醒(有锁的等待的线程可能优先).

### 对象的内存布局

Hotspot虚拟机中, 对象在内存中存储的布局可以分为三块区域: **对象头(Header) 实例数据(Instance Data) 和 对齐填充(Padding).**

对象头：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象才有）等。默认12Byte. 数组是16byte
实例数据：存放类的属性数据信息，包括父类的属性信息；
对齐填充：由于虚拟机要求 **对象起始地址必须是8字节的整数倍**。填充数据不是必须存在的，仅仅是为了字节对齐。

<img src="Screenshot 2024-11-14 at 16.03.00.png" alt="Screenshot 2024-11-14 at 16.03.00" style="zoom:50%;" />

## 偏向锁

偏向锁是针对加锁操作的优化手段. 

**偏向锁没有上锁操作**. 偏向锁没有解锁一说, 
偏向锁**撤销, 是指改变成其他锁状态**, 
无锁状态, 没有竞争的情况下.
轻量级锁, 少量竞争.
重锁,大量.
<img src="Screenshot 2024-11-14 at 20.16.00.png" alt="Screenshot 2024-11-14 at 20.16.00" style="zoom:50%;" />

在**大多数情况下**，锁不仅**不存在多线程竞争，而且总是由同一线程多次获得**，为消除数据在无竞争情况下锁重入（CAS操作）的开销而引入偏向锁。对于**没有锁竞争**的场合，**偏向锁有很好的优化效果**。

当JVM启用了偏向锁模式（jdk6默认开启），新创建对象的**Mark Word中的Thread ld为0**，处于**可偏向但未偏向**任何线程，也叫做匿名
偏向状态(anonymously biased).

### 偏向锁延迟

HotSpot 虚拟机在启动后 **4s 的延迟**才会对每个新建的对象开启偏向锁模式。**JVM启动时**会进行一系列的复杂活动，比如装载配置，系统类初始化等等。在**这个过程中会使用大量synchronized关键字对对象加锁**，且这些锁大多数**都不是偏向锁**。为了**减少初始化时间**，JVM默认**延时加载偏向锁**。

但是对于**明确已加载的class, 肯定马上上偏向锁**.

### 偏向锁撤销

看上边的 对象结构描述, 当显式**调用hashCode()**, 因为**没有地方存hashCode, 所以变为了无锁/其他**.

<img src="Screenshot 2024-11-14 at 17.11.42.png" alt="Screenshot 2024-11-14 at 17.11.42" style="zoom:50%;" />

<img src="Screenshot 2024-11-14 at 17.17.18.png" alt="Screenshot 2024-11-14 at 17.17.18" style="zoom:50%;" />

## 轻量级锁

偏向锁失败，虚拟机不会立即升级为重量级锁，它会尝试使用轻量级锁，此时Mark Word 的结构也变为轻量级锁的结构。
轻量级锁所适应的场景是线程交替执行同步块的场合，
如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁变为重量级锁。

## 偏向锁/轻量级锁 和 重锁 区别

偏向锁/轻量级锁是操作**用户态对象头mark word**, **重锁要切换内核态, 用park(), 但在使用park前后还是会尝试用先cas加锁**

## 总结: 锁对象状态转换

<img src="Screenshot 2024-11-14 at 19.08.55.png" alt="Screenshot 2024-11-14 at 19.08.55" style="zoom:50%;" />

### 可重入

其实是在java虚拟机栈中, push 一个markword副本的栈帧到栈中, 如果重入会不断push一个对象指向锁对象.

## 重偏向

<img src="Screenshot 2024-11-14 at 20.39.23.png" alt="Screenshot 2024-11-14 at 20.39.23" style="zoom:50%;" />

## 自旋

- **重量级锁竞争**的时候，还可以使用**自旋来优化**.
- **自旋会占用CPU 时间**，**单核** CPU 自旋就是浪费，**多核** CPU 自旋才能**发挥优势**。
- 在 Java 6之后自旋是自适应的, 比如对象**刚刚一次自旋成功过, 认为自旋成功的可能性会高，就多自旋几次**; 反之, 少自旋/不自旋.

**注意**：自旋的**目的**是为了减少线程挂起的次数，尽量避免直接挂起线程(挂起操作涉及系统调用，存在**用户态/内核态切换**，这才是重量级锁**最大的开销**)

## 锁粗化

如果JVM检测到有**一连串零碎的操作对同一对象的加锁**，将会**扩大加锁同步**的范围（即锁粗化）到整个操作序列的外部。

```
StringBuffer buffer = new StringBuffer();
public void append(){
	buffer.append("aaa").append(" bbb").append("ccc");
}
```

## 锁消除

删除**不必要的加锁**操作。锁消除是Java虚拟机在**JIT编译期间**，通过对运行上下文的扫描，**去除不可能存在共享资源竞争的锁**，通过锁消除，可以节省毫无意义的请求锁时间。

```
public void append(){
	StringBuffer buffer = new StringBuffer(); //没必要的sync加锁
	buffer.append("aaa").append(" bbb").append("ccc");
}
```

## 逃逸分析

一种有效减少Java 程序中**同步负载和内存堆分配压力**的**跨函数全局数据流分析算法**。
通过逃逸分析，Java Hotspot编译器能够分析出一个**新的对象的引用的使用范围**从而决定是否要将这个**对象分配到堆上**。逃逸分析的基本行为就是**分析对象动态作用域**.

### 方法逃逸（对象逃出当前方法）

当一个**对象**在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。
### 线程逃逸（对象逃出当前线程）

这个**对象**甚至可能**被其它线程访问**到，例如赋值给类变量或可以在其它线程中访问的实例变量。



