## 关键: 为什么TCC不会脏读, 而AT需要全局锁.

TCC 则是用差值来做cancel操作, 差值保存在rm注册分支时.



## 为什么会造成脏读

读到了, 事务执行到中途时 的值. 



## 为什么AT需要全局锁

AT想要直接把 value 覆盖还原成 previous image, 前提是要和预期值一样.



100 -> 900

| 1000 -> 900       | 1000 -> 1100 | 
| ----------------- | ------------ |
| 这个时候读到了900 |              |

**AT这种简直就是直接把关系型DB的事务提到了业务层, 想要直接把 value 还原成 previous image, 前提是要和预期值一样,**

1000 -> 900

​			900 -> 800

1000		

​			800

---

**TCC 则是用差值来做cancel操作, 差值保存在rm注册分支时**

900; 100

​				800; 200

800+100; 200-100







## AT 流程

上全局锁

上行锁

修改资源A; set 1000 -100 = 900; (没有冻结字段)

修改资源B; set 1000 +100 = 1100; (没有冻结字段)

**如果不加全局锁, 一旦修改了中途值, 如果需要rollback, 一般会导致无法补偿, 因为和 (post-updated)预期值不同**

解行锁

解全局锁

## TCC 流程

只上行锁

修改资源 (有冻结字段)

...

**如果修改中途值, 会再从 余额 移动到 冻结字段, 如果需要rollback, **



关键点: 因为冻结字段记录了, 变化的值(不是直接记录变化值)



## 参考

[一文简要概述Seata AT与TCC的区别](https://blog.csdn.net/qq_34707744/article/details/127497049)







