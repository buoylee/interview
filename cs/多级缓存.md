## 概述

CPU寄存器->CPU高速多级缓存->主内存, 看下图



## 高速缓冲存储器(CPU高速缓存)

CPU缓存, 即高速缓冲存储器，
位于 CPU 与 主内存 间, 容量小, 速度高 的存储器。
CPU的速度远高于主内存，CPU直接从内存取数需等一定时间，Cache存有**刚用过**或**循环使用**的数据，
再次使用该部分数据时, 可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率。

## 局部性

CPU访问存储设备, 存取数据/指令，趋于聚集在一片连续的区域中，这就是同部性原理.

时问局部性（Temporal Locality）：一个信息正被访问，近期很可能被再次访问。
比如循环、递归，方法的反复调用等。
空向局部性（Spatial Locality）：一个存储器的位置被引用，他附近的位置也会被引用。
比如顾序序执行的代码、连续创建的两个对象，数组等。

<img src="Screenshot 2024-11-10 at 14.45.50.png" alt="Screenshot 2024-11-10 at 14.45.50" style="zoom:50%;" />



## 缓存一致性

### 写传播（Write Propagation）

任何缓存数据的更改, 传播到对等缓存的其他副本(该缓存行的副本)。

### 事务串行化（Transaction Serialization）

单个内存位置的读/写必须被所有处理器以相同的顺序看到.
理论上，一致性可以在加载/存储粒度上执行。然而，在实践中，它通常在缓存块的粒度上执行。

### 一致性机制（**Coherence mechanisms**）

#### 总线窥探机制（bus snooping ）

**Write-invalidate**(写时失效)

当CPU写一个共享缓存块，其他缓存所有共享副本通过总线窥探失效。确保CPU只读写一个数据的一个副本。其他缓存中的所有其他副本都无效。
这是最常用的窥探协议。MSI、**MESI**、MOSI、MOESI和MESIF协议属于该类型。

**Write-update**

当CPU写一个共享缓存块，其他缓存所有共享副本都通过总线窥探更新, 广播到总线上的所有缓存中。
它比write-invalidate协议引起更大的总线流量。这种方法不常见。Dragon和firefly协议属于此类别。

#### 基于目录的机制（directory-based）!跳过

\>64处理器使用这种类型的缓存一致性.



## MESI协议

缓存行有4种不同的状态:

### 已修改Modified (M)

缓存行是脏的（dirty）, 与主存不同。别的CPU高速缓存要读主存，该缓存行必须回写主存，状态变为共享(S).

### 独占Exclusive (E)

缓存行只在当前CPU高速缓存中，干净的(与主存相同)。
别的缓存(指的某个CPU高速缓存)读取时，状态变为共享；
当前写数据时，变为已修改状态。

### 共享Shared (S)

缓存行存在于其它CPU高速缓存中, 且未修改。缓存行可以在任意时刻抛弃(无效)。

### 无效Invalid (I)

缓存行是无效的.

### 使用, 用 lock前缀指令

lock 会使 dirty行立即刷回主存, 为了尽量减少其他CPU高速缓存的等待时间

#### 边缘例子(2线程不加锁++导致比预期值小)

如果同时修改了CPU高速缓存, 慢的一边会失效, 最终结果是快的一边

### 读优化

有种O状态可以直接从其他CPU缓存读, 但是可能会造成数据不一致的问题(优先CPU还是从主存读)

## 缓存一致性失效

 ### 跨缓存行

cache line 64byte
32位系统分2次处理Long/double

### 早期没实现缓存一致性协议, 锁总线



## 总线锁定


锁定后, **只有当前CPU**对内存有访问权.
通过总线事务, CPU去内存取值, 总线试图并发使用总线事务。一个CPU执行总线事务时，总线会禁止其他CPU和IO设备执行内存的读写。
这是**总线仲裁 （Bus Arbitration） **会对竞争做出裁决.



