# base

## 用户态和内核态

- [怎样去理解Linux用户态和内核态] https://zhuanlan.zhihu.com/p/69554144

  > 其实从本质上说就是我们所说的内核，它是一种**特殊的软件程序**，特殊在哪儿呢？**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。
  >
  > 用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**





## 堆栈

- [怎样深入理解堆和栈] https://zhuanlan.zhihu.com/p/66922957



# I/O

- [5分钟搞懂Linux中直接I/O原理] https://cloud.tencent.com/developer/news/406991

  > # **直接I/O 优点**
  >
  > 最大的优点就是减少操作系统缓冲区和用户地址空间的拷贝次数。降低了CPU的开销，和内存带宽。对于某些应用程序来说简直是福音，将会大大提高性能。
  >
  > # **直接I/O 缺点**
  >
  > 直接IO并不总能让人如意。直接IO的开销也很大，应用程序没有控制好读写，将会导致磁盘读写的效率低下。磁盘的读写是通过磁头的切换到不同的磁道上读取和写入数据，如果需要写入数据在磁盘位置相隔比较远，就会导致寻道的时间大大增加，写入读取的效率大大降低。
  >
  > # **总结**
  >
  > 直接IO方式确实能够减少CPU的使用率以及内存带宽的占用，但是有时候也会造成性能的影响。所以在使用直接IO之前一定要清楚它的原理，只有在各项都清晰的情况下，才考虑使用。本人只是介绍了原理，如想深入，建议参考内核相关文档。



- [Linux I/O 原理和 Zero-copy 技术全面揭秘] https://segmentfault.com/a/1190000038700641
- [深入剖析Linux IO原理和几种零拷贝机制的实现] https://juejin.cn/post/6844903949359644680

## Linux 网络I/O模型 (5种)

- https://zhuanlan.zhihu.com/p/73575748



## 同步异步, 阻塞非阻塞

1. 同步异步 关注的是**消息通信机制**.

同步: 由*调用者*主动等待这个*调用*的结果。

异步: 调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。



2. 阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态.**

阻塞调用是指调用结果返回之前，当前线程会被挂起。

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

- https://www.youtube.com/watch?v=JOXGIatVLdY&list=PLynYQYUuPB-6V36AFWMdakIxdkcbSPyDF&index=70



## select poll epoll

select、poll、epoll都是I/O多路复用的机制。

I/O多路复用就是通过一种机制，一个进程可以监视多个文件描述符.

都是同步I/O, 它们都需要在读写事件就绪后线程自己进行读写，读写的过程阻塞的.

(异步I/O, 系统会负责把数据从内核空间拷贝到用户空间，无需线程自己再进行阻塞的读写，内核已经准备完成。)

### select

使用select模型处理IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，在连接数不是很高的情况下, 效率更差，select的优势在于能处理更多的连接.

select采用的是轮询模型，每次调用，都需要把fd_set集合从用户态拷贝到内核态，

为了减少数据拷贝以及轮询fd_set(文件描述符（File descriptor))带来的性能损坏，内核对被监控的fd_set集合大小做了限制，这个是通过宏FD_SETSIZE控制的，一般32位平台为1024，64位平台为2048.

### poll

poll本质上和select没有区别，只是它没有最大连接数的限制，原因是它是基于链表来存储的.

### epoll

epoll是Linux下IO多路复用select/poll的增强版本, 显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率, 因为它会复用文件描述符集合(共享内存)来传递结果.

它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了(采用回调机制，不是轮询的方式，不会随着FD数目的增加效率下降，只有活跃可用的FD才会调用callback函数)

#### 缺点:

- 虽然表面看起来epoll非常好，但是对于连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，因为epoll是建立在大量的函数回调的基础之上.
- epoll除了提供select/poll那种IO事件的水平触发(Level Triggered，水平触发只要有数据都会触发)外，还提供了边沿触发(Edge Triggered，边缘触发只有数据到来才触发，不管缓存区中是否还有数据)，这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率?
  - **epoll对文件描述符的操作有两种模式：`LT（level trigger）和ET（edge trigger）`。LT模式是默认模式，LT模式与ET模式的区别如下：**
    - LT模式：`应用程序可以不立即处理该事件`。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
    - ET模式：`应用程序必须立即处理该事件`。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

参考: 

- [select、poll和epoll模型] https://zhuanlan.zhihu.com/p/126532346
- [聊聊IO多路复用之select、poll、epoll详解(这个更详细)] https://www.jianshu.com/p/dfd940e7fca2 
- [高性能IO模型分析-浅析Select、Poll、Epoll机制（三）有代码解析] https://zhuanlan.zhihu.com/p/95872805

## 线程 进程 携程



# 虚拟内存

- [高频面试题——你真的搞懂物理内存与虚拟内存了吗] https://xie.infoq.cn/article/e082eae8d7dc5a3d5140225f9



# 进程

- [记一次腾讯面试：进程之间究竟有哪些通信方式？如何通信？ ---- 告别死记硬背] https://blog.csdn.net/m0_37907797/article/details/103188294





