## 主从复制

**全量复制的流程。主要有以下几步：**
1、从节点发送psync ? -1命令（因为第一次发送，不知道主节点的runId，所以为?，因为是第一次复制，所以offset=-1）。
2、主节点发现从节点是第一次复制，返回FULLRESYNC {runId} {offset}，runId是主节点的runId，offset是主节点目前的offset。
3、从节点接收主节点信息后，保存到info中。
4、主节点在发送FULLRESYNC后，启动bgsave命令，生成RDB文件（数据持久化）。
5、主节点发送RDB文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。
6、从节点清理自己的数据库数据。
7、从节点加载RDB文件，将数据保存到自己的数据库中。
8、如果从节点开启了AOF，从节点会异步重写AOF文件。



**关于部分复制有以下几点说明：**
　　1、部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施，使用psync[runId][offset]命令实现。当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点，这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。
　　2、主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。
　　3、当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当做psync参数发送给主节点，要求进行部分复制。
　　4、主节点接收到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在复制积压缓冲区中查找，如果offset之后的数据存在，则对从节点发送+COUTINUE命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。
　　5、主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。



## 哨兵

可以通过配置文件, 实现故障转移, 修改其他服务的脚本指向新的redis实例, 然后重启.





## twemproxy(proxy模式)

直接配置, 多个redis实例, 其他配置默认.



## redis cluster

节点数**至少3个master, 但是每个master需要1slave才有高可用.**
注意,Redis**自动维护集群配置文件**,**不要手动修改**,防止节点重启时产生集群信息错乱.

gossip 广播协议, meet(无所谓是否已在cluster内的node)、ping、pong消息是Gossip协议通信的载体.
要先握手, 客户端发起异步命令`cluster meet{ip}{port}`
接收者, 收到并回复pong消息.
之后节点间**彼此定期**通过ping/pong消息进行通信, 
只有**不同分片的slave之间不能直接通信**.
只有master可以进行下线投票.
每一個master一定和其他所有master連接.

cluster nodes命令,可以看到它们彼此已经感知到对方的存在.

**cluster-node-timeout**时间内通信**一直失败**,则**发送节点**会认为接收节点存在故障,把接收节点**标记**为**主观下线**(pfail)状态**(要当前node自己来判断)**。
**下线节点状态跟随消息**在集群内**传播**, **半数以上持有槽的主节点都标记**某个节点是主观下线时。**触发客观下线**流程.

### 故障转移

从节点要**检查**最后与**主节点断线时间**，判断**是否有资格替换故障主节点**.
更新触发故障选举时间(failover_auth_time), 到达该时间后, 发起选举.
持有槽的**主节点处理**故障**选举消息**, 每个**配置纪元**内, **持有槽的主节点只能投一票给slave**, **过半**后选出新master.



## 分配槽(slot)

只有**节点分配了槽,才能响应**和这些槽关联的键命令.
**cluster addslots**命令为节点**分配**槽.
16384个哈希槽, key通过CRC16校验后对16384取模

### 扩/缩容

只有新node加入集群, 才能移动slot到新node,
只有移动(清空)了node, 才能从集群移除node.



